---
title: "Target Markdown"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Target Markdown is a powerful R Markdown interface for reproducible analysis
pipelines, and the chapter at https://books.ropensci.org/targets/markdown.html
walks through it in detail. This R Markdown report the example from the chapter.
Try it out in both interactive and non-interactive modes, either by running the
code chunks in different ways or setting the `tar_interactive` chunk option.

# Packages

The example requires several R packages, and `targets` must be version 0.5.0.9000 or above.

```{r}
pkg <- c("tidyverse", "magrittr", "cowplot", "here", "arrow",
    "easystats", "glmmTMB", "ggcorrplot", "kableExtra")
```

```{r, eval = FALSE}
install.packages(pkg)
```

# Setup

If you are using old versions of `targets` (<= 0.7.0) and/or `knitr` (<= 1.33),
you will need to load the `targets` package in the R Markdown document in order
for Target Markdown code chunks to work.

Near the top of the document, you may also wish to remove the `_targets_r`
directory previously written by non-interactive runs of the report. Otherwise,
your pipeline may contain superfluous targets.

```{r}
library(targets)
tar_unscript()
```

# Globals

We first define some global options/functions common to all targets.

```{targets example-globals, tar_globals = TRUE}
options(tidyverse.quiet = TRUE)
pkg <- c("tidyverse", "magrittr", "cowplot", "here", "arrow",
    "easystats", "glmmTMB", "ggcorrplot", "kableExtra")
tar_option_set(packages = pkg)
dir_fun <- here::here("R")

# Source all the R files
lapply(
  X = list.files(
    path = dir_fun,
    pattern = "\\.R$",
    full.names = TRUE,
    all.files = TRUE,
    recursive = TRUE
  ),
  FUN = source)
```

# Targets

Our first target borrows the `airquality` dataset built into base R.

```{targets load-data}
list(
  # Connectance-Richness
  tar_target(param_CS,
    open_dataset(here("data", "fw_C_S.arrow"), format = "arrow") %>%
      collect()
    ),
  tar_target(simCS,
    open_dataset(here("data", "simCS.arrow"), format = "arrow") %>%
      collect()
    ),
  # Predator-Prey Size Ratio
  tar_target(simZ,
    open_dataset(here("data", "simZ.arrow"), format = "arrow") %>% collect()
    ),
  # Propagule size
  tar_target(simB,
    open_dataset(here("data", "simB.arrow"), format = "arrow") %>%
      collect()
    ),
  tar_target(param_G,
    open_dataset(here("data", "fw_G.arrow"), format = "arrow") %>%
      collect()
  ),
  tar_target(simG,
    open_dataset(here("data", "simG.arrow"), format = "arrow") %>%
      collect()
  ),
  tar_target(sim_total,
    open_dataset(here("data", "sim_total.arrow"), format = "arrow") %>%
      collect()
  ),
  tar_target(sim_param,
    open_dataset(here("data", "sim_param.arrow"), format = "arrow") %>%
      collect()
  )
)
```

## Data explanation

- Every food-web (`fw_id`) was ran according to three sequential `scenario`:
  - `pred_present`: The predator is present
  - `pred_extirpated`: We then extirpated the predator
  - `pred_reintroduced`: lastly, we reintroduced the predator!

- We collected a bunch of metrics for each simulation:
  - `fw_id`
  - `scenario`
  - `richness`,  `persistence`
  - `bm_sp`: vector of species biomass
  - `bm_total`
  - `bm_pred`, `bm_cons`, `bm_prod`: predator, consumer, and primary producer
    biomass
  - `bm_init_pred`, `bm_init_cons`, `bm_init_prod`: Same than above for initial
    biomass
  - `species_alive`: vector of species alive among `bm_sp`
  - `A_alive`, `A_init`: interaction matrix of alive species, and initial
    interaction matrix
  - `tlvl`: vector of species trophic level
  - `tlvl_max`, `tlvl_mean`, `tlvl_w_mean`: max, mean and weighted mean
  - `omnivory`, `omnivory_mean`: vector of omnivory values, avg
  - `cv_com`, `cv_species_mean`, `cv_species`: community, average species cv, and
    vector of species cv
  - `int_mean`, `int_per_cap_mean`: avg and per capita avg interaction
  - `richness_init`, `bm_init`: initial richness and biomass
  - `tlvl_extirpated`, `tlvl_introduced`:
  - `i_extirpated`, `i_introduced`:


# Make targets

```{r}
ncpu <- future::availableCores()
if (ncpu > 4) {
  tar_make_future(workers = min(future::availableCores() - 1, 24))
} else {
  tar_make()
}
```

The `targets` dependency graph helps your readers understand the steps of your pipeline at a high level.

```{r}
tar_visnetwork()
```

At this point, you can go back and run `{targets}` chunks in interactive mode without interfering with the code or data of the non-interactive pipeline.

# Output

```{r load-fun}
sapply(pkg, require, character.only = TRUE)

dir_fun <- here::here("R")
lapply(
  X = list.files(
    path = dir_fun,
    pattern = "\\.R$",
    full.names = TRUE,
    all.files = TRUE,
    recursive = TRUE
  ),
  FUN = source)
```

```{r}
tar_load(sim_total)
tar_load(sim_param)

sim <- sim_param %>%
  select(-fw, nb_link, Z) %>%
  left_join(sim_total) %>%
  select(sim_id, S, C, Z, nb_link, fw, rep, everything())
save(sim, file = here("data", "sim.RData"))
```


- Should discard foodweb that had persistence less than 80% as Toby did

```{r}
tar_load(c(param_CS, simCS))

# Only few replicates have a low persistence
simCS %>%
  filter(scenario == "pred_present", persistence < .8)
# All food-webs have predators
simCS %>%
  filter(scenario == "pred_present", tlvl_max < 2)

simCS %<>%
  mutate(
    mean_cv_pop = map_dbl(cv_species, mean)
  ) %>%
  select(!where(is.list)) %>%
  left_join(param_CS %>% select(!where(is.list))) %>%
  mutate(
    scenario = factor(scenario,
      levels = c("pred_present", "pred_extirpated", "pred_reintroduced")),
    stab_com = 1 / cv_com,
    avg_stab_pop = 1 / cv_species_mean,
    mean_stab_pop = 1 / mean_cv_pop

  ) %>%
  relocate(all_of(c("stab_com", "avg_stab_pop", "mean_stab_pop")), .after = richness) %>%
  select(-cv_com, -cv_species_mean, -mean_cv_pop)

```

## Predator removal

```{r}
p_stab_com <- simCS %>%
  ggplot(aes(y = log(stab_com), x = S, color = scenario)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(
    y = "Community stability",
    x = "Initial foodweb richness",
    color = "Scenario"
    ) +
  facet_grid(cols = vars(C)) +
  theme_bw() +
  theme(legend.position = "bottom")

p_avg_stab_pop <- simCS %>%
  ggplot(aes(y = log(avg_stab_pop), x = S, color = scenario)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(
    y = "Average population stability (weighted)",
    x = "Initial foodweb richness",
    color = "Scenario"
    ) +
  facet_grid(cols = vars(C)) +
  theme_bw() +
  theme(legend.position = "bottom")

p_mean_stab_pop <- simCS %>%
  ggplot(aes(y = log(mean_stab_pop), x = S, color = scenario)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(
    y = "Mean population stability (non weighted)",
    x = "Initial foodweb richness",
    color = "Scenario"
    ) +
  facet_grid(cols = vars(C)) +
  theme_bw() +
  theme(legend.position = "bottom")

leg <- get_legend(p_avg_stab_pop)

p_toby_res <- plot_grid(
  p_mean_stab_pop + theme(legend.position = "none"),
  p_stab_com + theme(legend.position = "none"),
  p_avg_stab_pop+ theme(legend.position = "none"),
  leg,
  nrow = 4,
  rel_heights = c(1, 1, 1, .2)
)

ggsave(
  here::here("report", "figs", "p_toby_res.png"),
  plot = p_toby_res,
  scale = 2.4,
  width = 140,
  height = 140 * .8,
  units = "mm"
)
```


```{r}
exp_effect <- simCS %>%
  select(-c(richness_init:tlvl_introduced)) %>%
  pivot_longer(richness:int_per_cap_mean,
    names_to = "metric", values_to = "values") %>%
  pivot_wider(names_from = "scenario", values_from = "values") %>%
  mutate(
    effect_extirpation = pred_extirpated - pred_present,
    effect_extirpation_ratio = effect_extirpation / pred_present,
    effect_reintro = pred_reintroduced - pred_extirpated,
    effect_reintro_ratio = effect_reintro / pred_extirpated,
    effect_resilience = pred_reintroduced - pred_present,
    effect_resilience_ratio = effect_resilience / pred_present
  )
```

```{r}
p_extirpation_effect <- exp_effect %>%
  filter(effect_extirpation_ratio < 5) %>%
  ggplot(aes(x = as.factor(S), y = effect_extirpation_ratio, color = as.factor(C))) +
  geom_boxplot() +
  geom_hline(yintercept = 0)+
  labs(
    y = "Extirpation effect (extirpated - pred present)/pred present",
    x = "Initial foodweb richness",
    color = "Connectance"
    ) +
  facet_wrap(~metric, scales = "free_y") +
  theme_bw() +
  theme(legend.position = "bottom")
ggsave(
  here::here("report", "figs", "p_extirpation_effect.png"),
  plot = p_extirpation_effect,
  scale = 2,
  width = 140,
  height = 140 * .5,
  units = "mm"
)
```


```{r}
p_effect_reintro <- exp_effect %>%
  filter(abs(effect_reintro_ratio) < 5) %>%
  ggplot(aes(x = as.factor(S), y = effect_reintro_ratio, color = as.factor(C))) +
  geom_boxplot() +
  labs(
    y = "Reintroduction effect (reintro - extirpated)/extirpated",
    x = "Initial foodweb richness",
    color = "Connectance"
    ) +
  geom_hline(yintercept = 0)+
  facet_wrap(~metric, scales = "free_y") +
  theme_bw() +
  theme(legend.position = "bottom")
ggsave(
  here::here("report", "figs", "p_reintro_effect.png"),
  plot = p_effect_reintro,
  scale = 2,
  width = 140,
  height = 140 * .5,
  units = "mm"
)
```

```{r}
p_resilience_effect <- exp_effect %>%
  filter(effect_resilience_ratio < 5) %>%
  ggplot(aes(x = as.factor(S), y = effect_resilience_ratio, color = as.factor(C))) +
  geom_boxplot() +
  geom_hline(yintercept = 0)+
  labs(
    y = "Resilience effect (reintro - pred present)/pred present",
    x = "Initial foodweb richness",
    color = "Connectance"
    ) +
  facet_wrap(~metric, scales = "free_y") +
  theme_bw() +
  theme(legend.position = "bottom")
ggsave(
  here::here("report", "figs", "p_resilience_effect.png"),
  plot = p_resilience_effect,
  scale = 2,
  width = 140,
  height = 140 * .5,
  units = "mm"
)
```

```{r}
mod_rich <- glmmTMB(richness ~ scenario * S * C + (1|fw_id/rep), data = simCS)
mod_stab <- glmmTMB(cv_com ~ scenario * S * C + (1|fw_id/rep), data = simCS)
```

```{r}
mod_rich <- glmmTMB(richness ~ scenario * S * C + (1|fw_id/rep), data = simCS)
```



